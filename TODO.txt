=== FIX ===
- Un preassegnamento può essere considerato solamente se il field non viene mai modificato in tutto il programma
- Bisogna controllare se all'interno delle funzioni si fa override dei field, in questo caso quei field non vanno bene se usati nelle time expression

=== FIX ===
(Forse questo va implementto in maniera differete)
Samuele,

questo codice lo riconosce come problematico (expired code)

stipula Sample5 {
      field x= "2024-01-01"
      init Init

      @Init A:f()[] {
                "2024-01-01"  @Cont { } = @End
      } = @Cont
}

invece quest’altro no

stipula Sample5 {
      field x= "2024-01-01"
      init Init

      @Init A:f()[] {
                x  @Cont { } = @End
      } = @Cont
}


Puoi sistemare l’analizzatore?

Cosimo

=== FIX ===
da sistemare anche questo

stipula Sample5 {
  field x,y
  init Q0

  agreement(A,B)(x,y) {
          A,B : x,y
  } => @Q0

  @Q0 A: f()[] {
          now + x+2 >> @Q2 {} => @Q3  // ev.1
  } => @Q1

  @Q1 B: g()[] {
          now + y+1 >> @Q3 {} => @Q4  // ev.2
  } => @Q2
}

ev.2 e` dead code soltanto quando x+1 > y

Cosimo

=== TESI ===
- Riscrivere le formule presente nella tesi in maniera corretta

=== PARTI DA AGGIUNGERE ===
- Cercare di implementare il controllo sul tempo logico dell'esecuzioni